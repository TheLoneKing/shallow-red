/**
 * Game subscribes to gameId events and handles them posting moves
 * generated by player object that must implement two methods:
 * 
 * getNextMove(array of uciMoves) returns uciMove
 * getReply(chat event) returns chat message  
 * 
 */
const twit              = require('twit');
const consumerKey       = process.env.TWITTER_CONSUMER_KEY;
const consumerSecret    = process.env.TWITTER_CONSUMER_SECRET;
const accessToken       = process.env.TWITTER_ACCESS_TOKEN;
const accessTokenSecret = process.env.TWITTER_ACCESS_TOKEN_SECRET;

const config = {
    consumer_key: consumerKey,
    consumer_secret: consumerSecret,
    access_token: accessToken,
    access_token_secret: accessTokenSecret
};

const Twitter = new twit(config);

class Game {

    /**
     * Initialise with interface to lichess.
     */
    constructor(api, name, player) {
        this.api = api;
        this.name = name;
        this.player = player;
        this.engine = player.getEngine();
    }

    start(gameId) {
        this.gameId = gameId;
        this.engine.setGameId(gameId);
        this.engine.setApi(this.api);
        this.api.streamGame(gameId, (event) => this.handler(event));

        // Tweet about this game
        this.tweetTheGame(this.gameId);
    }

    tweetTheGame(gameId) {
        let tweet = {
            status: `Started a new game on lichess at... https://lichess.org/${gameId}`
        };
        Twitter.post('statuses/update', tweet, (err, data, response) => {
            if (err) {
                console.error("Error while tweeting...");
            } else {
                console.log("Tweeted about the game successfully!");
            }
        });
    }

    handleChatLine(event) {
        if (event.username !== this.name) {
            const reply = this.player.getReply(event);
            if (reply) {
                this.api.chat(this.gameId, event.room, reply);
            }
        }
    }

    handler(event) {
        switch (event.type) {
            case "chatLine":
                this.handleChatLine(event);
                break;
            case "gameFull":
                this.colour = this.playingAs(event);
                this.playNextMove(event.state.moves);
                break;
            case "gameState":
                this.playNextMove(event.moves);
                break;
            default:
                console.log("Unhandled game event : " + JSON.stringify(event));
        }
    }

    playNextMove(previousMoves) {
        let moves = (previousMoves === "") ? [] : previousMoves.split(" ");
        let isMyTurn = this.isTurn(this.colour, moves);
        this.engine.playNextMove(moves, isMyTurn);
    }

    playingAs(event) {
        return (event.white.name === this.name) ? "white" : "black";
    }

    isTurn(colour, moves) {
        var parity = moves.length % 2;
        return (colour === "white") ? (parity === 0) : (parity === 1);
    }
}
  
module.exports = Game;
